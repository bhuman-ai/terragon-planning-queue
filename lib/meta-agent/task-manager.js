/**
 * Task Management for Meta-Agent
 * Creates and manages task folder structures
 */

const fs = require('fs').promises;
const path = require('path');

class TaskManager {
  constructor(config = {}) {
    this.workingDir = config.workingDir || process.cwd();
    this.tasksDir = path.join(this.workingDir, 'tasks');
  }

  /**
   * Create a new task with proper folder structure
   */
  async createTask(taskSpec) {
    const { title, description, requirements, decomposition } = taskSpec;

    // Generate task ID
    const taskNumber = await this.getNextTaskNumber();
    const taskId = String(taskNumber).padStart(3, '0');
    const taskName = this.sanitizeTaskName(title);
    const taskDirName = `task-${taskId}-${taskName}`;
    const taskPath = path.join(this.tasksDir, taskDirName);

    // Create task structure
    await this.createTaskStructure(taskPath);

    // Create task.md
    const taskMd = await this.generateTaskDocument({
      taskId,
      title,
      description,
      requirements,
      decomposition,
      timestamp: new Date().toISOString()
    });

    await fs.writeFile(path.join(taskPath, 'task.md'), taskMd);

    // Create spec.md if we have requirements
    if (requirements && Object.keys(requirements).length > 0) {
      const specMd = await this.generateSpecDocument(requirements);
      await fs.writeFile(path.join(taskPath, 'spec.md'), specMd);
    }

    // Create terragon-context.json
    const context = {
      taskId,
      taskDirName,
      createdAt: new Date().toISOString(),
      terragonInstances: [],
      status: 'planning'
    };

    await fs.writeFile(
      path.join(taskPath, 'terragon-context.json'),
      JSON.stringify(context, null, 2)
    );

    return {
      taskId,
      taskDirName,
      taskPath,
      success: true
    };
  }

  /**
   * Get the next available task number
   */
  async getNextTaskNumber() {
    try {
      await fs.access(this.tasksDir);
    } catch {
      // Tasks directory doesn't exist, create it
      await fs.mkdir(this.tasksDir, { recursive: true });
      return 1;
    }

    const entries = await fs.readdir(this.tasksDir);
    const taskNumbers = entries
      .filter(entry => entry.startsWith('task-'))
      .map(entry => {
        const match = entry.match(/task-(\d+)-/);
        return match ? parseInt(match[1]) : 0;
      })
      .filter(num => num > 0);

    return taskNumbers.length > 0 ? Math.max(...taskNumbers) + 1 : 1;
  }

  /**
   * Create task folder structure
   */
  async createTaskStructure(taskPath) {
    // Create main task directory
    await fs.mkdir(taskPath, { recursive: true });

    // Create subdirectories
    const subdirs = ['context', 'artifacts', 'research', 'terragon-outputs'];
    for (const subdir of subdirs) {
      await fs.mkdir(path.join(taskPath, subdir), { recursive: true });
    }
  }

  /**
   * Generate task.md content
   */
  async generateTaskDocument(data) {
    const { taskId, title, description, requirements, decomposition, timestamp } = data;

    let content = `# Task ${taskId}: ${title}

## Status: Planning
Created: ${timestamp}
Updated: ${timestamp}

## Description
${description}

## Objective
${description}

`;

    // Add requirements section if available
    if (requirements && Object.keys(requirements).length > 0) {
      content += `## Requirements
`;
      for (const [key, value] of Object.entries(requirements)) {
        if (typeof value === 'object' && value.question) {
          content += `- **${value.question}**: ${value.answer || 'Not specified'}\n`;
        } else {
          content += `- ${key}: ${value}\n`;
        }
      }
      content += '\n';
    }

    // Add decomposition if available
    if (decomposition && decomposition.length > 0) {
      content += `## Task Decomposition
`;
      decomposition.forEach((task, idx) => {
        content += `${idx + 1}. ${task.title}
   - Duration: ${task.duration || 'TBD'}
   - Status: Pending
`;
      });
      content += '\n';
    }

    content += `## Implementation Plan
[To be generated by Terragon]

## Progress Log
- ${timestamp}: Task created by Meta-Agent
- ${timestamp}: Requirements gathered and documented
`;

    return content;
  }

  /**
   * Generate spec.md content
   */
  async generateSpecDocument(requirements) {
    let content = `# Detailed Specifications
Generated: ${new Date().toISOString()}

## Requirements Summary

`;

    // Organize requirements by category
    const categorized = {};

    for (const [key, value] of Object.entries(requirements)) {
      const category = value.category || 'general';
      if (!categorized[category]) {
        categorized[category] = [];
      }
      categorized[category].push({ key, value });
    }

    // Write categorized requirements
    for (const [category, items] of Object.entries(categorized)) {
      content += `### ${category.charAt(0).toUpperCase() + category.slice(1)} Requirements

`;
      for (const { key, value } of items) {
        if (typeof value === 'object' && value.question) {
          content += `**${value.question}**
- Answer: ${value.answer || 'Not specified'}
- Type: ${value.type || 'unknown'}
${value.explanation ? `- Note: ${value.explanation}` : ''}

`;
        } else {
          content += `- ${key}: ${value}\n`;
        }
      }
    }

    return content;
  }

  /**
   * Update task status
   */
  async updateTaskStatus(taskDirName, newStatus) {
    const taskPath = path.join(this.tasksDir, taskDirName);
    const taskMdPath = path.join(taskPath, 'task.md');

    try {
      let content = await fs.readFile(taskMdPath, 'utf-8');

      // Update status line
      content = content.replace(
        /## Status: .+/,
        `## Status: ${newStatus}`
      );

      // Update timestamp
      content = content.replace(
        /Updated: .+/,
        `Updated: ${new Date().toISOString()}`
      );

      // Add to progress log
      const progressMarker = '## Progress Log';
      const progressIndex = content.indexOf(progressMarker);
      if (progressIndex !== -1) {
        const beforeProgress = content.substring(0, progressIndex + progressMarker.length);
        const afterProgress = content.substring(progressIndex + progressMarker.length);
        content = `${beforeProgress}\n- ${new Date().toISOString()}: Status changed to ${newStatus}${afterProgress}`;
      }

      await fs.writeFile(taskMdPath, content);

      return { success: true };
    } catch (error) {
      console.error('Error updating task status:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Add Terragon instance to task
   */
  async addTerragonInstance(taskDirName, instanceId, instanceUrl) {
    const contextPath = path.join(this.tasksDir, taskDirName, 'terragon-context.json');

    try {
      const contextData = JSON.parse(await fs.readFile(contextPath, 'utf-8'));

      contextData.terragonInstances.push({
        id: instanceId,
        url: instanceUrl,
        createdAt: new Date().toISOString()
      });

      await fs.writeFile(contextPath, JSON.stringify(contextData, null, 2));

      return { success: true };
    } catch (error) {
      console.error('Error adding Terragon instance:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Sanitize task name for folder
   */
  sanitizeTaskName(title) {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 50);
  }

  /**
   * Get task info by directory name
   */
  async getTaskInfo(taskDirName) {
    const taskPath = path.join(this.tasksDir, taskDirName);

    try {
      const taskMd = await fs.readFile(path.join(taskPath, 'task.md'), 'utf-8');
      const context = JSON.parse(
        await fs.readFile(path.join(taskPath, 'terragon-context.json'), 'utf-8')
      );

      // Extract status from task.md
      const statusMatch = taskMd.match(/## Status: (.+)/);
      const status = statusMatch ? statusMatch[1].trim() : 'Unknown';

      return {
        taskDirName,
        taskId: context.taskId,
        status,
        createdAt: context.createdAt,
        terragonInstances: context.terragonInstances,
        content: taskMd
      };
    } catch (error) {
      console.error('Error reading task info:', error);
      return null;
    }
  }

  /**
   * List all tasks
   */
  async listTasks() {
    try {
      const entries = await fs.readdir(this.tasksDir);
      const taskDirs = entries.filter(entry => entry.startsWith('task-'));

      const tasks = [];
      for (const taskDir of taskDirs) {
        const taskInfo = await this.getTaskInfo(taskDir);
        if (taskInfo) {
          tasks.push(taskInfo);
        }
      }

      // Sort by task ID
      tasks.sort((a, b) => a.taskId.localeCompare(b.taskId));

      return tasks;
    } catch (error) {
      console.error('Error listing tasks:', error);
      return [];
    }
  }
}

module.exports = TaskManager;
